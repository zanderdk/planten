<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.14"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Plante: WebSockets</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
  $(document).ready(initResizable);
/* @license-end */</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Plante
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.14 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('md_esp32-snippets_cpp_utils__design_notes__web_sockets.html','');});
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">WebSockets </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>#WebSockets The <a class="el" href="class_web_socket.html">WebSocket</a> implementation attempts to implement <a href="https://tools.ietf.org/html/rfc6455">RFC 6455 - The WebSocket Protocol</a>.</p>
<p>When an <a class="el" href="struct_h_t_t_p.html">HTTP</a> request arrives, we examine the request to see if it is a request to open a new <a class="el" href="class_web_socket.html">WebSocket</a> connection. If it is, we respond with the acknowledgement that we are prepared to be a <a class="el" href="class_web_socket.html">WebSocket</a> partner. Once done, the socket that was once used to handle the REST request now becomes the one used to handle bi-directional communications between the ESP32 (original <a class="el" href="class_web_socket.html">WebSocket</a> server) and the client (browser/Node.js).</p>
<p>Since we don't know when a client may transmit, it could actually transmit at any time. As such we want to register an asynchronous callback handler that will be invoked when the client sends in some <a class="el" href="class_web_socket.html">WebSocket</a> data. To handle this, we then need to <code>select()</code> on the <a class="el" href="class_web_socket.html">WebSocket</a> socket and, when it wakes, invoke the callback handler. We must <b>not</b> issue a new <code>select()</code> until the <a class="el" href="class_web_socket.html">WebSocket</a> message has been consumed.</p>
<p>It is anticipated that a <a class="el" href="class_web_socket.html">WebSocket</a> message could be large. The first use case I have come across for using WebSockets is for file transfer and since we have 4MBytes of flash and only 512K of RAM (of which likely only 100K or so may be available) we are likely going to run out of RAM if we wish to write a large file to flash file systems. What this means is that we likely can't buffer a large <a class="el" href="class_web_socket.html">WebSocket</a> data message in RAM.</p>
<p>For example, imagine a <a class="el" href="class_web_socket.html">WebSocket</a> client wants to send a file of 1MByte to the ESP32. That is more data than we have RAM so we can't hold that message in its entirety in RAM. What we need to do is "read some" and then "write some" and repeat until all has been consumed. This sounds like the concept of a stream. We would have an input stream (data coming into the ESP32) associated with the <a class="el" href="class_web_socket.html">WebSocket</a> and an output stream (data going out from the ESP32) being written to the file. We could thus read a small section of the input, write it to the output and continue while we have new data in the input.</p>
<p>This sounds workable ... so let us now think about how we might go about creating an input stream for a <a class="el" href="class_web_socket.html">WebSocket</a> message. Each <a class="el" href="class_web_socket.html">WebSocket</a> message starts with a <a class="el" href="class_web_socket.html">WebSocket</a> frame which contains, amongst other things, the length of the payload data. This means that we know up front how much of the remaining data is payload. This becomes essential as we can't rely on an "end of file" marker in the input stream to indicate the end of the <a class="el" href="class_web_socket.html">WebSocket</a> payload. The reason for this is that the <a class="el" href="class_web_socket.html">WebSocket</a> is a TCP stream that will be used to carry multiple sequential messages.</p>
<p>Let us now invent a new class. Let us call it a <a class="el" href="class_socket_input_record_streambuf.html">SocketInputRecordStreambuf</a>. It will have a constructor of the form:</p>
<div class="fragment"><div class="line">SocketInputRecordStreambuf(Socket &amp;socket, size_t dataLength, size_t bufferSize=512)</div></div><!-- fragment --><p>The <code>socket</code> is the TCP/IP socket that we are going to read data from. The <code>dataLength</code> is the size of the data we wish to read. The class will extend <code>std::streambuf</code>. It will internally maintain a data buffer of size <code>bufferSize</code>. Initially, the buffer will be empty. When a read is performed on the stream, a call to <code>underflow()</code> will be made (this is a <code>std::streambuf</code> virtual function).</p>
<p>Our rules for this class include:</p>
<ul>
<li>We must <b>not</b> read more the <code>dataLength</code> bytes from the socket.</li>
<li>We must <b>indicate</b> and <code>EOF</code> once we have had <code>dataLength</code> bytes consumed by a stream reader.</li>
<li>The class must implement a <code>discard()</code> method that will discard further bytes from the socket such that the total number of bytes read from the socket will equal <code>dataLength</code>.</li>
<li>Deleting an instance of the class must invoke <code>discard()</code>.</li>
</ul>
<h2><a class="el" href="class_file.html" title="A logical representation of a file. ">File</a> transfer</h2>
<p>WebSockets make a great file transfer technology. While this is more an application utilization of the technology than the design of the framework, we'll capture it here. Let us first set the scene. We have a client application that wishes to transmit a file. We will assume that the file is composed of three logical components:</p>
<ul>
<li>The file name</li>
<li>The file length</li>
<li>The content of the file</li>
</ul>
<p>It would be wrong to expect the client to send the file as one continuous unit in one <a class="el" href="class_web_socket.html">WebSocket</a> message. The reason for this is that the client would have to have loaded the complete file into its memory buffers in order to send it. As such, we should assume that the client will send the files as one or more "parts" where each part represents a piece of the file.</p>
<p>We thus invent the following protocol:</p>
<p>For the first message we have:</p>
<div class="fragment"><div class="line">+-----------------------+-----------+----+--------------------+-----------+</div><div class="line">| transferId (32bit/LE) | file name | \0 | length (32bits/LE) | Data .... |</div><div class="line">+-----------------------+-----------+----+--------------------+-----------+</div></div><!-- fragment --><p>For subsequent messages we have:</p>
<div class="fragment"><div class="line">+-----------------------+-----------+</div><div class="line">| transferId (32bit/LE) | Data .... |</div><div class="line">+-----------------------+-----------+</div></div><!-- fragment --><p> Let us look at these.</p>
<ul>
<li><code>transferId</code> - An Id that is randomly generated by the client. This is used to associate multiple messages for the same file together.</li>
<li><code>file name</code> - The name of the file that the client wishes to send. Can include paths. This will be used to determine where on the file system the file will be written.</li>
<li><code>length</code> - The size of the file in bytes. Knowing the size will allow us to know when the whole file has been received.</li>
</ul>
<p>We will create an encapsulation class called <code><a class="el" href="class_web_socket_file_transfer.html">WebSocketFileTransfer</a></code>. </p>
</div></div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.14 </li>
  </ul>
</div>
</body>
</html>
